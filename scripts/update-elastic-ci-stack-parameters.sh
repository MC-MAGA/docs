#!/bin/bash
set -euo pipefail

cloudformation_url="${1:-https://s3.amazonaws.com/buildkite-aws-stack/latest/aws-stack.yml}"
terraform_repo="${2:-buildkite/terraform-buildkite-elastic-ci-stack-for-aws}"
terraform_branch="${3:-main}"

cloudformation_output="data/content/aws-stack.yml"
mapping_output="data/content/cloudformation-terraform-mapping.yml"

echo "Fetching CloudFormation template from ${cloudformation_url}" >&2
curl --fail --silent --show-error --location "${cloudformation_url}" > "${cloudformation_output}"

echo "Fetching Terraform variables from GitHub" >&2
terraform_variables_url="https://raw.githubusercontent.com/${terraform_repo}/${terraform_branch}/variables.tf"
curl --fail --silent --show-error --location "${terraform_variables_url}" > /tmp/terraform-variables.tf

echo "Generating parameter mapping" >&2

python3 <<'EOF'
import sys
import re
import yaml
from difflib import get_close_matches

def cloudformation_constructor(loader, tag_suffix, node):
    if isinstance(node, yaml.ScalarNode):
        return loader.construct_scalar(node)
    elif isinstance(node, yaml.SequenceNode):
        return loader.construct_sequence(node)
    elif isinstance(node, yaml.MappingNode):
        return loader.construct_mapping(node)
    return None

yaml.add_multi_constructor('!', cloudformation_constructor, Loader=yaml.SafeLoader)

with open('data/content/aws-stack.yml', 'r') as f:
    cf_template = yaml.safe_load(f)

with open('/tmp/terraform-variables.tf', 'r') as f:
    tf_content = f.read()

terraform_vars = {}
current_var = None
for line in tf_content.split('\n'):
    var_match = re.match(r'variable "([^"]+)"', line)
    if var_match:
        current_var = var_match.group(1)
        terraform_vars[current_var] = None
    elif current_var and re.match(r'\s+type\s*=\s*(.+)', line):
        type_match = re.match(r'\s+type\s*=\s*(.+)', line)
        if type_match:
            tf_type = type_match.group(1).strip()
            terraform_vars[current_var] = tf_type
        current_var = None

def pascal_to_snake(name):
    result = name
    
    acronym_map = {
        'KMS': '_kms_', 'ARN': '_arn_', 'ARNS': '_arns_', 'ARNs': '_arns_',
        'S3': '_s3_', 'ACL': '_acl_', 'VPC': '_vpc_', 'EC2': '_ec2_',
        'IAM': '_iam_', 'API': '_api_', 'URL': '_url_', 'ID': '_id_',
        'IDS': '_ids_', 'IPs': '_ips_', 'IP': '_ip_', 'SSH': '_ssh_',
        'SSO': '_sso_', 'SSE': '_sse_', 'IOPS': '_iops_', 'CPU': '_cpu_',
        'IO': '_io_', 'TTL': '_ttl_'
    }
    
    for acronym, replacement in acronym_map.items():
        result = result.replace(acronym, replacement)
    
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', result)
    s2 = re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1)
    snake = s2.lower()
    
    snake = re.sub('_+', '_', snake)
    snake = snake.strip('_')
    
    return snake

def find_best_match(cf_param, terraform_vars):
    # Manual mappings for parameters with non-standard naming
    manual_mappings = {
        'BuildkiteAgentSigningKeySSMParameter': 'pipeline_signing_jwks_parameter_store_path',
        'BuildkiteAgentSigningKeyID': 'pipeline_signing_jwks_key_id',
        'BuildkiteAgentVerificationKeySSMParameter': 'pipeline_verification_jwks_parameter_store_path',
    }
    
    if cf_param in manual_mappings:
        tf_var = manual_mappings[cf_param]
        if tf_var in terraform_vars.keys():
            return tf_var
    
    expected = pascal_to_snake(cf_param)
    if expected in terraform_vars.keys():
        return expected
    
    matches = get_close_matches(expected, terraform_vars.keys(), n=1, cutoff=0.8)
    if matches:
        return matches[0]
    
    simple = cf_param.lower()
    if simple in terraform_vars.keys():
        return simple
    
    return None

mapping = {}
unmapped = []
cf_params = cf_template.get('Parameters', {})

for cf_param in sorted(cf_params.keys()):
    tf_var = find_best_match(cf_param, terraform_vars)
    if tf_var:
        tf_type = terraform_vars[tf_var]
        mapping[cf_param] = {"variable": tf_var, "type": tf_type}
    else:
        unmapped.append(cf_param)
        mapping[cf_param] = "N/A"
        print(f"WARNING: No Terraform match found for CloudFormation parameter: {cf_param}", file=sys.stderr)

output_lines = [
    "# CloudFormation Parameter to Terraform Variable Mapping",
    "#",
    "# This file is auto-generated by scripts/update-elastic-ci-stack-parameters.sh",
    "# DO NOT EDIT MANUALLY - Run the script to regenerate",
    "#",
    "# Format:",
    "#   CloudFormationParameter:",
    "#     variable: terraform_variable_name",
    "#     type: terraform_type",
    "# Or: CloudFormationParameter: N/A (for parameters with no Terraform equivalent)",
    ""
]

for cf_param in sorted(mapping.keys()):
    if mapping[cf_param] == "N/A":
        output_lines.append(f"{cf_param}: N/A")
    else:
        output_lines.append(f"{cf_param}:")
        output_lines.append(f"  variable: {mapping[cf_param]['variable']}")
        output_lines.append(f"  type: {mapping[cf_param]['type']}")

with open('data/content/cloudformation-terraform-mapping.yml', 'w') as f:
    f.write('\n'.join(output_lines) + '\n')

print(f"\n✓ Generated mapping with {len(mapping)} parameters", file=sys.stderr)
if unmapped:
    print(f"⚠ Warning: {len(unmapped)} CloudFormation parameters have no Terraform equivalent", file=sys.stderr)
else:
    print(f"✓ All CloudFormation parameters successfully mapped!", file=sys.stderr)

EOF

echo "" >&2
echo "Done! Files updated:" >&2
echo "  - ${cloudformation_output}" >&2
echo "  - ${mapping_output}" >&2
