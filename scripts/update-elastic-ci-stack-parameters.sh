#!/bin/bash
set -euo pipefail

# This script fetches both CloudFormation and Terraform configurations
# and automatically generates the parameter mapping between them

cloudformation_url="${1:-https://s3.amazonaws.com/buildkite-aws-stack/latest/aws-stack.yml}"
terraform_repo="${2:-buildkite/terraform-buildkite-elastic-ci-stack-for-aws}"
terraform_branch="${3:-main}"

cloudformation_output="data/content/aws-stack.yml"
mapping_output="data/content/cloudformation-terraform-mapping.yml"

echo "Fetching CloudFormation template from ${cloudformation_url}" >&2
curl --fail --silent --show-error --location "${cloudformation_url}" > "${cloudformation_output}"

echo "Fetching Terraform variables from GitHub" >&2
terraform_variables_url="https://raw.githubusercontent.com/${terraform_repo}/${terraform_branch}/variables.tf"
curl --fail --silent --show-error --location "${terraform_variables_url}" > /tmp/terraform-variables.tf

echo "Generating parameter mapping" >&2

# Use Python to parse both files and generate mapping with fuzzy matching
python3 <<'EOF'
import sys
import re
import yaml
from difflib import get_close_matches

# Add CloudFormation tag constructors to handle !Ref, !GetAtt, etc.
def cloudformation_constructor(loader, tag_suffix, node):
    """Generic constructor for CloudFormation intrinsic functions"""
    if isinstance(node, yaml.ScalarNode):
        return loader.construct_scalar(node)
    elif isinstance(node, yaml.SequenceNode):
        return loader.construct_sequence(node)
    elif isinstance(node, yaml.MappingNode):
        return loader.construct_mapping(node)
    return None

yaml.add_multi_constructor('!', cloudformation_constructor, Loader=yaml.SafeLoader)

# Read CloudFormation template
with open('data/content/aws-stack.yml', 'r') as f:
    cf_template = yaml.safe_load(f)

# Parse Terraform variables
with open('/tmp/terraform-variables.tf', 'r') as f:
    tf_content = f.read()

terraform_vars = set()
for match in re.finditer(r'variable "([^"]+)"', tf_content):
    terraform_vars.add(match.group(1))

def pascal_to_snake(name):
    """Convert PascalCase to snake_case with intelligent acronym handling"""
    # First, handle common acronyms by keeping them together
    result = name
    
    # Replace common acronyms with lowercase versions temporarily
    acronym_map = {
        'KMS': '_kms_', 'ARN': '_arn_', 'ARNS': '_arns_', 'ARNs': '_arns_',
        'S3': '_s3_', 'ACL': '_acl_', 'VPC': '_vpc_', 'EC2': '_ec2_',
        'IAM': '_iam_', 'API': '_api_', 'URL': '_url_', 'ID': '_id_',
        'IDS': '_ids_', 'IPs': '_ips_', 'IP': '_ip_', 'SSH': '_ssh_',
        'SSO': '_sso_', 'SSE': '_sse_', 'IOPS': '_iops_', 'CPU': '_cpu_',
        'IO': '_io_', 'TTL': '_ttl_'
    }
    
    for acronym, replacement in acronym_map.items():
        result = result.replace(acronym, replacement)
    
    # Convert remaining PascalCase to snake_case
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', result)
    s2 = re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1)
    snake = s2.lower()
    
    # Clean up multiple underscores
    snake = re.sub('_+', '_', snake)
    snake = snake.strip('_')
    
    return snake

def find_best_match(cf_param, terraform_vars):
    """Find the best Terraform variable match for a CloudFormation parameter"""
    # Try exact conversion first
    expected = pascal_to_snake(cf_param)
    if expected in terraform_vars:
        return expected
    
    # Try fuzzy matching
    matches = get_close_matches(expected, terraform_vars, n=1, cutoff=0.8)
    if matches:
        return matches[0]
    
    # Try lowercase simple conversion
    simple = cf_param.lower()
    if simple in terraform_vars:
        return simple
    
    return None

# Generate mapping
mapping = {}
unmapped = []
cf_params = cf_template.get('Parameters', {})

for cf_param in sorted(cf_params.keys()):
    tf_var = find_best_match(cf_param, terraform_vars)
    if tf_var:
        mapping[cf_param] = tf_var
    else:
        unmapped.append(cf_param)
        mapping[cf_param] = "N/A"  # Mark as N/A when no Terraform equivalent exists
        print(f"WARNING: No Terraform match found for CloudFormation parameter: {cf_param}", file=sys.stderr)

# Write mapping file
output_lines = [
    "# CloudFormation Parameter to Terraform Variable Mapping",
    "#",
    "# This file is auto-generated by scripts/update-elastic-ci-stack-parameters.sh",
    "# DO NOT EDIT MANUALLY - Run the script to regenerate",
    "#",
    "# Format: CloudFormationParameter: terraform_variable_name",
    "# N/A indicates the parameter has no Terraform equivalent",
    ""
]

for cf_param in sorted(mapping.keys()):
    output_lines.append(f"{cf_param}: {mapping[cf_param]}")

with open('data/content/cloudformation-terraform-mapping.yml', 'w') as f:
    f.write('\n'.join(output_lines) + '\n')

print(f"\n✓ Generated mapping with {len(mapping)} parameters", file=sys.stderr)
if unmapped:
    print(f"⚠ Warning: {len(unmapped)} CloudFormation parameters have no Terraform equivalent", file=sys.stderr)
else:
    print(f"✓ All CloudFormation parameters successfully mapped!", file=sys.stderr)

EOF

echo "" >&2
echo "Done! Files updated:" >&2
echo "  - ${cloudformation_output}" >&2
echo "  - ${mapping_output}" >&2
